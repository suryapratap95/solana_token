"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SPLConfig = void 0;
const tslib_1 = require("tslib");
const bignumber_js_1 = tslib_1.__importDefault(require("bignumber.js"));
const async_retry_1 = tslib_1.__importDefault(require("async-retry"));
const web3_js_1 = require("@solana/web3.js");
const token_1 = tslib_1.__importDefault(require("./token"));
//@ts-ignore spl-token has type: module set in it's package.json, which means it's CJS export won't be detected/built :c
const spl_token_1 = require("@solana/spl-token"); // assert { "resolution-mode": "node" }
class SPLConfig extends token_1.default {
    constructor(config) {
        super(config);
        this.contractAddress = config.contractAddress;
    }
    async getSPLMetadata() {
        const meta = await (await this.getProvider()).getParsedAccountInfo(new web3_js_1.PublicKey(this.contractAddress));
        const metaData = meta?.value?.data;
        if (!metaData || Buffer.isBuffer(metaData))
            throw new Error(`Failed to get valid SPL metadata for ${this.contractAddress}`);
        if (metaData.program !== 'spl-token')
            throw new Error(`Invalid program type, expected 'spl-token', got ${metaData.program}`);
        const parsedInfo = metaData.parsed.info;
        const decimals = parsedInfo.decimals;
        const atomicPer = 10 ** decimals;
        if (!isFinite(atomicPer) || !atomicPer.toString().endsWith('0'))
            throw new Error(`Unable to compute sane atomic unit count for ${decimals}, got ${atomicPer}`);
        this.decimals = decimals;
        this.base[1] = atomicPer;
    }
    async getTx(txId) {
        const connection = await this.getProvider();
        const stx = await connection.getParsedTransaction(txId, {
            commitment: this.finality,
            maxSupportedTransactionVersion: 0,
        });
        console.log(stx);
        if (!stx)
            throw new Error('Confirmed tx not found');
        const transfer = stx.transaction.message.instructions.find((op) => {
            op = op;
            return (op.program === 'spl-token' &&
                ['transfer', 'transferChecked'].includes(op.parsed.type)
            //   && [op.parsed.info.destination, op.parsed.info.source].includes(this.address)
            );
        });
        if (!transfer)
            throw new Error(`Tx does not contain a valid transfer instruction`);
        if (!transfer.parsed?.info)
            throw new Error(`tx ${txId} Missing required parsed metadata (transfer instruction info)`);
        const { source, destination, amount } = transfer.parsed.info;
        if (!(source && destination && amount))
            throw new Error(`tx ${txId} Missing required parsed metadata (transfer instruction source, destination, or amount)`);
        const getAndValidateTokenAccOwner = async (tokenAccAddress) => {
            const tokenAccInfo = await connection.getParsedAccountInfo(new web3_js_1.PublicKey(tokenAccAddress));
            const tokenAccInfoValue = tokenAccInfo.value;
            if (!tokenAccInfoValue ||
                Buffer.isBuffer(tokenAccInfoValue) ||
                Buffer.isBuffer(tokenAccInfoValue.data))
                throw new Error(`tx ${txId} contains an unknown token account ${source}`);
            const tokenAccInfoParsedOwner = tokenAccInfoValue.data.parsed.info.owner;
            if (!tokenAccInfoParsedOwner)
                throw new Error(`unable to resolve address for token account ${destination}`);
            return tokenAccInfoParsedOwner;
        };
        const actualSourceAddress = await getAndValidateTokenAccOwner(source);
        const actualDestinationAddress = await getAndValidateTokenAccOwner(destination);
        const currentSlot = await connection.getSlot(this.finality);
        if (!stx.meta)
            throw new Error(`Unable to resolve transaction ${txId}`);
        const tx = {
            from: actualSourceAddress,
            to: actualDestinationAddress,
            amount: new bignumber_js_1.default(amount),
            blockHeight: new bignumber_js_1.default(stx.slot),
            pending: false,
            confirmed: currentSlot - stx.slot >= 1,
        };
        return tx;
    }
    async _createTxUnsigned(amount, to, fee) {
        const pubKey = new web3_js_1.PublicKey(await this.getPublicKey());
        const connection = await this.getProvider();
        const blockHashInfo = await (0, async_retry_1.default)(async (bail) => {
            try {
                return await connection.getLatestBlockhash(this.finality);
            }
            catch (e) {
                if (e.message?.includes('blockhash'))
                    throw e;
                else
                    bail(e);
                throw new Error('Unreachable');
            }
        }, { retries: 3, minTimeout: 1000 });
        const transaction = new web3_js_1.Transaction({ ...blockHashInfo, feePayer: pubKey });
        const mint = new web3_js_1.PublicKey(this.contractAddress);
        const fromTokenAccount = await (0, spl_token_1.getOrCreateAssociatedTokenAccount)(connection, this.wallet, mint, pubKey);
        const toTokenAccount = await (0, spl_token_1.getAssociatedTokenAddress)(mint, new web3_js_1.PublicKey(to));
        transaction.add((0, spl_token_1.createTransferInstruction)(fromTokenAccount.address, toTokenAccount, pubKey, +new bignumber_js_1.default(amount).toNumber()));
        if (!this?.config?.opts?.disablePriorityFees && fee) {
            transaction.add(web3_js_1.ComputeBudgetProgram.setComputeUnitPrice({
                microLamports: fee.computeUnitPrice.toNumber(),
            }));
            transaction.add(web3_js_1.ComputeBudgetProgram.setComputeUnitLimit({
                units: fee.computeBudget.toNumber(),
            }));
        }
        return transaction;
    }
    async ready() {
        await super.ready();
        await this.getSPLMetadata();
    }
}
exports.SPLConfig = SPLConfig;
exports.default = SPLConfig;
//# sourceMappingURL=spl.js.map