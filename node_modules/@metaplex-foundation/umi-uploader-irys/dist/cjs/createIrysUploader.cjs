'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var umi = require('@metaplex-foundation/umi');
var umiWeb3jsAdapters = require('@metaplex-foundation/umi-web3js-adapters');
var web3_js = require('@solana/web3.js');
var BigNumber = require('bignumber.js');
var buffer = require('buffer');
var promisePool = require('@supercharge/promise-pool');
var errors = require('./errors.cjs');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var BigNumber__default = /*#__PURE__*/_interopDefaultLegacy(BigNumber);

// PromisePool is a dependency the Irys client already requires, so using it here has no extra cost.

/**
 * This method is necessary to import the Irys package on both ESM and CJS modules.
 * Without this, we get a different structure on each module:
 * - CJS: { default: [Getter], WebIrys: [Getter] }
 * - ESM: { default: { default: [Getter], WebIrys: [Getter] } }
 * This method fixes this by ensure there is not double default in the imported package.
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function _removeDoubleDefault(pkg) {
  if (pkg && typeof pkg === 'object' && 'default' in pkg && 'default' in pkg.default) {
    return pkg.default;
  }
  return pkg;
}
// Size of Irys transaction header.
const HEADER_SIZE = 2_000;

// Minimum file size for cost calculation.
const MINIMUM_SIZE = 80_000;
const gatewayUrl = id => `https://gateway.irys.xyz/${id}`;
function createIrysUploader(context, uploaderOptions = {}) {
  // eslint-disable-next-line @typescript-eslint/naming-convention
  let _irys = null;
  uploaderOptions = {
    providerUrl: context.rpc.getEndpoint(),
    ...uploaderOptions
  };
  const getUploadPriceFromBytes = async bytes => {
    const irys = await getIrys();
    const price = await irys.getPrice(bytes);
    return bigNumberToAmount(price.multipliedBy(uploaderOptions.priceMultiplier ?? 1.1));
  };
  const getUploadPrice = async files => {
    const bytes = files.reduce((sum, file) => sum + HEADER_SIZE + Math.max(MINIMUM_SIZE, file.buffer.byteLength), 0);
    return getUploadPriceFromBytes(bytes);
  };
  const upload = async (files, options) => {
    const irys = await getIrys();
    const amount = await getUploadPrice(files);
    await fund(amount);
    const manifestMap = options?.manifest === true ? new Map() : undefined;
    const result = await promisePool.PromisePool.for(files).withConcurrency(uploaderOptions.uploadConcurrency ?? 10).onTaskFinished((_, pool) => options?.onProgress?.(pool.processedPercentage())).process(async file => {
      if (options?.signal?.aborted) throw new errors.IrysAbortError();
      const buffer$1 = buffer.Buffer.from(file.buffer);
      const irysTx = irys.createTransaction(buffer$1, {
        tags: getGenericFileTagsWithContentType(file)
      });
      await irysTx.sign();
      const {
        status,
        data: {
          id
        }
      } = await irys.uploader.uploadTransaction(irysTx);
      if (status >= 300) throw new errors.AssetUploadFailedError(status);
      manifestMap?.set(file.fileName, id);
      return id;
    });
    if (manifestMap) {
      const manifest = await irys.uploader.generateFolder({
        items: manifestMap
      });
      const {
        id
      } = await irys.upload(JSON.stringify(manifest), {
        tags: [{
          name: 'Type',
          value: 'manifest'
        }, {
          name: 'Content-Type',
          value: 'application/x.irys-manifest+json'
        }
        // ...(options?.manifestTags ?? []),
        ]
      });

      return [gatewayUrl(id)];
    }
    return result.results.map(gatewayUrl);
  };
  const uploadJson = async json => {
    const file = umi.createGenericFileFromJson(json);
    const uris = await upload([file]);
    return uris[0];
  };
  const getBalance = async () => {
    const irys = await getIrys();
    const balance = await irys.getBalance();
    return bigNumberToAmount(balance);
  };
  const fund = async (amount, skipBalanceCheck = false) => {
    const irys = await getIrys();
    let toFund = amountToBigNumber(amount);
    if (!skipBalanceCheck) {
      const balance = await irys.getBalance();
      toFund = toFund.isGreaterThan(balance) ? toFund.minus(balance) : new BigNumber__default["default"](0);
    }
    if (toFund.isLessThanOrEqualTo(0)) {
      return;
    }
    await irys.fund(toFund);
  };
  const withdrawAll = async () => {
    const irys = await getIrys();
    const balance = await irys.getBalance();
    const minimumBalance = new BigNumber__default["default"](5000);
    if (balance.isLessThan(minimumBalance)) {
      return;
    }
    await irys.withdrawAll();
  };
  const withdraw = async amount => {
    const irys = await getIrys();
    try {
      await irys.withdrawBalance(amountToBigNumber(amount));
    } catch (e) {
      throw new errors.IrysWithdrawError(e instanceof Error ? e.message : e.toString());
    }
  };
  const getIrys = async () => {
    const oldPayer = _irys?.getSigner().publicKey;
    const newPayer = uploaderOptions.payer ?? context.payer;
    if (oldPayer && umi.publicKey(new Uint8Array(oldPayer)) !== newPayer.publicKey) {
      _irys = null;
    }
    if (!_irys) {
      _irys = await initIrys();
    }
    return _irys;
  };
  const initIrys = async () => {
    const token = 'solana';
    const defaultAddress = context.rpc.getCluster() === 'devnet' ? 'https://devnet.irys.xyz' : 'https://uploader.irys.xyz';
    const address = uploaderOptions?.address ?? defaultAddress;
    const irysOptions = {
      timeout: uploaderOptions.timeout,
      providerUrl: uploaderOptions.providerUrl
    };
    const payer = uploaderOptions.payer ?? context.payer;

    // If in node use node irys, else use web irys.
    const isNode =
    // eslint-disable-next-line no-prototype-builtins
    typeof window === 'undefined' || window.process?.hasOwnProperty('type');
    let irys;
    if (isNode && umi.isKeypairSigner(payer)) irys = await initNodeIrys(address, payer, irysOptions);else {
      irys = await initWebIrys(address, payer, irysOptions);
    }
    try {
      // Check for valid irys node.
      await irys.utils.getBundlerAddress(token);
    } catch (error) {
      throw new errors.FailedToConnectToIrysAddressError(address, error);
    }
    return irys;
  };
  const initNodeIrys = async (address, keypair, options) => {
    const bPackage = _removeDoubleDefault(await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('@irys/upload')); }));
    const cPackage = _removeDoubleDefault(await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('@irys/upload-solana')); }));
    return bPackage.Uploader(cPackage.Solana).bundlerUrl(address).withWallet(keypair.secretKey).withIrysConfig(options).build();
  };
  const initWebIrys = async (address, payer, options) => {
    const wallet = {
      publicKey: umiWeb3jsAdapters.toWeb3JsPublicKey(payer.publicKey),
      signMessage: message => payer.signMessage(message),
      signTransaction: async web3JsTransaction => umiWeb3jsAdapters.toWeb3JsLegacyTransaction(await payer.signTransaction(umiWeb3jsAdapters.fromWeb3JsLegacyTransaction(web3JsTransaction))),
      signAllTransactions: async web3JsTransactions => {
        const transactions = web3JsTransactions.map(umiWeb3jsAdapters.fromWeb3JsLegacyTransaction);
        const signedTransactions = await payer.signAllTransactions(transactions);
        return signedTransactions.map(umiWeb3jsAdapters.toWeb3JsLegacyTransaction);
      },
      sendTransaction: async (web3JsTransaction, connection, options = {}) => {
        const {
          signers: web3JsSigners = [],
          ...sendOptions
        } = options;
        const signers = web3JsSigners.map(web3JsSigner => umi.createSignerFromKeypair(context, umiWeb3jsAdapters.fromWeb3JsKeypair(web3_js.Keypair.fromSecretKey(web3JsSigner.secretKey))));
        let transaction = umiWeb3jsAdapters.fromWeb3JsLegacyTransaction(web3JsTransaction);
        transaction = await umi.signTransaction(transaction, [payer, ...signers]);
        const signature = await context.rpc.sendTransaction(transaction, {
          ...sendOptions,
          preflightCommitment: sendOptions.preflightCommitment
        });
        return umi.base58.deserialize(signature)[0];
      }
    };
    const bPackage = _removeDoubleDefault(await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('@irys/web-upload')); }));
    const cPackage = _removeDoubleDefault(await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('@irys/web-upload-solana')); }));
    const irys = await bPackage.WebUploader(cPackage.WebSolana).withProvider(wallet).bundlerUrl(address).withIrysConfig(options).build();
    try {
      // Try to initiate irys.
      await irys.ready();
    } catch (error) {
      throw new errors.FailedToInitializeIrysError(error);
    }
    return irys;
  };
  return {
    getUploadPriceFromBytes,
    getUploadPrice,
    upload,
    uploadJson,
    getBalance,
    fund,
    withdrawAll,
    withdraw,
    irys: getIrys
  };
}
const isIrysUploader = uploader => 'irys' in uploader && 'getBalance' in uploader && 'fund' in uploader && 'withdrawAll' in uploader;
const bigNumberToAmount = bigNumber => umi.lamports(bigNumber.decimalPlaces(0).toString());
const amountToBigNumber = amount => new BigNumber__default["default"](amount.basisPoints.toString());
const getGenericFileTagsWithContentType = file => {
  if (!file.contentType) {
    return file.tags;
  }
  return [{
    name: 'Content-Type',
    value: file.contentType
  }, ...file.tags];
};

exports.createIrysUploader = createIrysUploader;
exports.isIrysUploader = isIrysUploader;
//# sourceMappingURL=createIrysUploader.cjs.map
